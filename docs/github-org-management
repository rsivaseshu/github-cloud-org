Options available

Terraform / OpenTofu (GitHub provider) — declarative IaC for orgs, repos, teams, permissions, branch protection, Actions settings, etc. Great for reproducible, auditable state. 
HashiCorp Developer
+1

GitHub REST & GraphQL APIs (Octokit / custom scripts) — full API coverage for many org settings; use for anything Terraform can’t do yet or for one-off calls. Good for automation via scripts. 
GitHub Docs
+1

GitHub CLI (gh) — convenient for scripted/CLI workflows and calling the API; useful for ad-hoc automation in CI/CD pipelines. 
GitHub CLI
+1

GitHub Apps / Probot apps (e.g., Safe-Settings) — policy-as-code approach that stores org/repo settings centrally (YAML) and enforces them automatically via a GitHub App. Excellent for “settings as code” with PR-based changes and enforcement. 
GitHub
+1

SCIM / SSO provisioning (IdP integration) — automates user and team provisioning and deprovisioning from your IdP (Azure AD/Okta etc.). Use this for enterprise user lifecycle. 
GitHub Docs
+1

GitHub Actions (organization-level workflows + automation) — can run org automation (e.g., run scripts on repo creation, auto-tagging, audits). Good for glue logic, but beware secrets/permissions scope. 
DevOps Journal

Third-party manager tools / scripts — community tools like github-org-manager, safe-settings, or custom orchestration using Octokit/gh. Useful for specific needs or migrations. 
GitHub
+1

Pros / Cons (quick)

Terraform / OpenTofu

Declarative, stateful, reviewable, works well with CI (PR → plan → apply).

Good for infra-like resources (repos, teams, branch rules).

− Some org settings or newest GitHub features may not be supported instantly.

GitHub REST/GraphQL (custom scripts / Octokit)

Most complete API coverage and fastest to adopt new endpoints.

− Imperative; you must write idempotent code and manage state yourself.

gh CLI

Fast to script, good for small automation tasks.

− Not ideal for large-scale drift detection / long term state.

Safe-Settings / Policy-as-Code apps

Excellent for central policy files (YAML), enforcement, and PR-based changes.

− It's a GitHub App (third-party) — check trust, hosting, and scaling.

SCIM / IdP

Best practice for enterprise user lifecycle and role assignments.

− Requires GitHub Enterprise Cloud features and IdP setup.

GitHub Actions

Great orchestration; can react to org events (repo created) and apply defaults.

− Needs careful permissions and secrets strategy.

(References: Terraform provider docs, GitHub REST API docs, GH CLI docs, Safe-Settings repo, SCIM docs.) 
GitHub Docs
+4
HashiCorp Developer
+4
GitHub Docs
+4

Recommended, pragmatic architecture (what I’d implement as a DevOps engineer)

Source of truth: Terraform (or OpenTofu) + Git repository

Store org-level configuration (teams, team membership, repository definitions, branch protection, rulesets) as Terraform files.

Use a dedicated repo (e.g., org-infra) — PRs → CI → terraform plan → terraform apply after reviews.

Why: Terraform gives state, drift detection, and easy integration with CI/CD and secret management. 
HashiCorp Developer
+1

Policy-as-code enforcement: Safe-Settings (GitHub App) or equivalent

Deploy Safe-Settings or a similar GitHub App to enforce repo-level policies defined in YAML in a central admin repo.

Use it to enforce branch protections, merge strategies, repo settings and to auto-apply defaults on new repos. 
GitHub

User and access provisioning: SCIM + SSO

Connect your IdP (Okta, Azure AD / Microsoft Entra) to GitHub SCIM for automated membership and provisioning.

Use SCIM to keep user membership and team mapping in sync. 
GitHub Docs
+1

Glue & custom: gh CLI + Octokit scripts + GitHub Actions

Use gh and Octokit for tasks Terraform can’t do (e.g., certain developer settings, some third-party app installations, or one-off migrations).

Implement GitHub Actions workflows in the org-infra repo for pre-apply validation, tests, and to call gh/Octokit for non-Terraform steps. 
GitHub CLI
+1

Audit & alerting

Enable the audit log and wire it to your SIEM / CloudWatch / Splunk for change detection.

Create daily/weekly drift checks: compare API state → Terraform/OpenTofu state and fail PRs if drift detected.

Third-party apps & integrations

Manage trusted apps via GitHub Marketplace & OAuth/GitHub App review processes.

Use Terraform or API where possible to register app installations or to configure app permissions (some limited support). If not available, use Octokit to script installations. (Check provider coverage per app.)

Practical constraints & gotchas

Not every GitHub UI setting is available in Terraform; sometimes you must use REST API or GitHub Apps. Always check the provider docs for resource coverage. 
HashiCorp Developer
+1

Enterprise-only features (e.g., Enterprise Managed Users, certain SCIM features) require GitHub Enterprise Cloud. 
GitHub Docs

Safe-Settings is a third-party app — evaluate security, host it yourself if needed, or use an internal Probot app. 
GitHub

Concrete next steps you can run immediately

Inventory

Export current org settings (repos, teams, branch protections, required reviewers, actions settings) using a script (Octokit/gh) to create a baseline. I can provide that script. 
GitHub Docs
+1

PoC

Create a small org-infra repo.

Add Terraform for: one repo, one team, a branch protection rule, and a team membership.

Add a GitHub Action that runs terraform plan for PRs.

(Terraform provider docs & examples are here.) 
HashiCorp Developer

Policy enforcement

Evaluate Safe-Settings: try installing it into a sandbox org and create YAML policies for branch protections and repo defaults. 
GitHub

Provisioning

If you use Azure AD / Okta, configure SCIM for automated user provisioning and sync groups → org teams. 
Microsoft Learn
+1

Drift detection & audit

Schedule a job (GitHub Action or external CI) to compare live org state (via API) vs Terraform state and create issues/alerts on drift.